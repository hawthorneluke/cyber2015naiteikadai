;break = dat 0x3e0 ;break


set pc, get_hardware


;グローバル変数
:field_w dat 5 ;フィールドの幅
:field_h dat 5 ;フィールドの高さ
:mine_count dat 5 ;地雷の数
:player_x dat 0 ;プレイヤーのx
:player_y dat 0 ;プレイヤーのy

:field_mem dat 0x9000 ;フィールドデータが始まる番地(0x9000+field_w*field_hまで)
;field_mem = 0xbc : b = 0: 開いてないマス、1: 開いてるマス、2:旗。
;c = 0~8: 周りの地雷の数（開いてないマスなら0）、;f: 地雷

:monitor dat 0 ;モニタのハードID
:keyboard dat 0 ;キーボードのハードID
:clock dat 0 ;クロックのハードID
:monitor_mem dat 0x8000 ;モニタのメモリが始まる番地(0x8180まで)

:screen_w dat 32 ;モニタのマスの横の数
:screen_h dat 12 ;モニタのマスの縦の数


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:get_hardware
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
hwn z ;繋がってるハードの台数をzに

:hardware_check_loop
sub z, 1
ife ex, 0xffff
set pc, game_setup ;繋がってるハードの全てをチェックしたのでこのループから出る
hwq z ;代z目のハードの情報を取得

:monitor_check
;idでモニタチェック
ifn a, 0xf615
set pc, keyboard_check
ifn b, 0x7349
set pc, keyboard_check
;idがモニタと一致
set [monitor], z
set pc, hardware_check_loop

:keyboard_check
;idでキーボードチェック
ifn a, 0x7406
set pc, clock_check
ifn b, 0x30cf
set pc, clock_check
;idがキーボードと一致
set [keyboard], z
set pc, hardware_check_loop

:clock_check
;idでクロックチェック
ifn a, 0xb402
set pc, hardware_check_loop
ifn b, 0x12d0
set pc, hardware_check_loop
;idがキーボードと一致
set [clock], z
set pc, hardware_check_loop


set pc, game_setup


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:game_setup
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;モニタが使うメモリ番地を指定
set a, 0
set b, [monitor_mem]
hwi [monitor]

;モニタが使うフォントのメモリ番地を指定
set a, 1
set b, 0 ;デフォルトを使う
hwi [monitor]

;モニタが使うパレットのメモリ番地を指定
set a, 2
set b, 0 ;デフォルトを使う
hwi [monitor]

;モニタの枠の色を指定
set a, 3
set b, 0xd ;ピンク
hwi [monitor]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:field_setup ;フィールドセットアップ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
set a, [field_mem]
set b, 0 ;b=field_mem上のポインタ。これがランダムに進まされ、この値に地雷を置く
set c, [field_w] ;c=field_memの長さ
mul c, [field_h]

set j, [mine_count]

:field_setup_j

set x, 3 ;これをランダムな値に

set i, 0

:field_setup_i
add b, 1
ife b, c ;bがfield_memを超えたなら0にリセット
set b, 0

;bに既に地雷があるならスキップ
set z, a
add z, b
set z, [z]
and z, 0xf
ife z, 0xf ;地雷がるなら
set pc, field_setup_i

add i, 1
ife i, x
set pc, field_setup_add_mine
set pc, field_setup_i

:field_setup_add_mine
;地雷をa+bに置く
set z, a
add z, b
set [z], 0x1f ;地雷

sub j, 1
ife j, 0
set pc, field_setup_end
set pc, field_setup_j


:field_setup_end






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:game_loop ;ゲームのループ
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

jsr get_input_start

jsr display_field

jsr game_clear_check

set pc, game_loop

dat 0


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:game_clear_check ;ゲームをクリアしたかをチェック
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
set push, i
set push, j
set push, a
set push, b
set push, c

set c, 0 ;地雷でない開いてないマズのカウント

set j, 0

:game_clear_check_j

set i, 0

:game_clear_check_i

set a, j
mul a, [field_w]
add a, i
add a, [field_mem]

set b, [a]
shr b, 4
ife b, 1 ;開いてるマスなら数えない
set pc, game_clear_check_i_end

;マスが開いてないなら
set b, [a]
and b, 0xf
ife b, 0xf ;開いてないマスが地雷なら数えない
set pc, game_clear_check_i_end

;開いてない、地雷でないマスなら数える
add c, 1

:game_clear_check_i_end
add i, 1
ifn i, [field_w]
set pc, game_clear_check_i

add j, 1
ifn j, [field_h]
set pc, game_clear_check_j

ife c, 0
jsr game_won

:game_clear_check_return
set c, pop
set b, pop
set a, pop
set j, pop
set i, pop
set pc, pop



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:game_won ;地雷でない開いてないマスがもう残ってなくて、ゲームをクリアした
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;勝利
dat 0x3e0 ;break
set pc, pop


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:get_input_start ;キーボードからの入力を処理
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
set push, a
set push, c

:get_input

set a, 1 ;バッファーにある押されたキーを取得
hwi [keyboard]

ife c, 0 ;バッファーにキーがないなら戻る
set pc, get_input_return

ife c, 0x80
set pc, get_input_up

ife c,0x81
set pc, get_input_down

ife c, 0x82
set pc, get_input_left

ife c, 0x83
set pc, get_input_right

ife c, " "
set pc, get_input_open

ife c, 0x11
set pc, get_input_open

ife c, "f"
set pc, get_input_flag

;違うキーだったので次のを確認
set pc, get_input


:get_input_up
set a, [player_y]
sub a, 1
ife a, -1
set pc, get_input
set [player_y], a
set pc, get_input

:get_input_down
set a, [player_y]
add a, 1
ife a, [field_h]
set pc, get_input
set [player_y], a
set pc, get_input

:get_input_left
set a, [player_x]
sub a, 1
ife a, -1
set pc, get_input
set [player_x], a
set pc, get_input

:get_input_right
set a, [player_x]
add a, 1
ife a, [field_w]
set pc, get_input
set [player_x], a
set pc, get_input

:get_input_open
jsr open_cell
set pc, get_input

:get_input_flag
jsr flag_cell
set pc, get_input

:get_input_return
set c, pop
set a, pop
set pc, pop




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:open_cell ;マスを開く
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
set push, a
set push, b
set push, c
set push, i
set push, j
set push, x
set push, y
set push, z

jsr get_cell ;aにプレイヤーがいるマスの番地を取得


set b, [a]
shr b, 4
ife b, 1 ;開いてるなら
set pc, open_cell_return

set b, [a]
and b, 0xf

ife b, 0xf
jsr open_mine

;周りに何個の地雷があるかを確認
jsr open_empty ;ここでopen_safeで使うレジスタをスタックにプッシュしてあげる
;（再帰呼び出しでいっぱいスタックにプッシュしてないように）

:open_cell_return
set z, pop
set y, pop
set x, pop
set j, pop
set i, pop
set c, pop
set b, pop
set a, pop
set pc, pop



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:open_mine ;地雷を開く
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;ゲームオーバー
set a, 0xffff
dat 0x3e0 ;break
set pc, pop



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:open_empty ;aでの空のマスを開く
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;open_cellでここで使うレジスタを既にスタックにプッシュしてある


;aが既に開いてるマスなら戻る
set b, [a]
shr b, 4
ife b, 1 ;開いてるなら
set pc, open_empty_return

set c, 0 ;周りにある地雷のカウント

;プレイヤーがいるマスの周りのマスを地雷の存在をチェック

;x,y = ここのマス(a)のx,y座標
set x, a
sub x, [field_mem]
mod x, [field_w]

set y, a
sub y, [field_mem]
div y, [field_w]



set j, y
sub j, 1

:open_empty_j

ifu j, 0
set pc, open_empty_j_end

ife j, [field_h]
set pc, open_empty_loop_end

set i, x
sub i, 1

:open_empty_i

ifl i, 0
set pc, open_empty_i_end

ife i, [field_w]
set pc, open_empty_i_end


set b, j
mul b, [screen_w]
add b, i
add b, [field_mem]
;bが調べてるマスの番地を持つ

set b, [b]
and b, 0xf
ife b, 0xf ;地雷なら
add c, 1 ;カウント++

:open_empty_i_end
add i, 1
set z, i
sub z, x
ifn z, 2
set pc, open_empty_i

:open_empty_j_end
add j, 1
set z, j
sub z, y
ife z, 2
set pc, open_empty_loop_end
set pc, open_empty_j


:open_empty_loop_end
;カウントがcに入ってる

set b, 0x10 ;開いてるマス
bor b, c ;周りのマスでの地雷の数
set [a], b ;このマスを書き換え

:open_empty_return
set pc, pop


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:flag_cell ;できたらマスに旗を置く
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
set push, a
set push, b

jsr get_cell ;aにプレイヤーがいるマスの番地を取得

set b, [a]
shr b, 4
ifn b, 0 ;セルが開いてない状態でないなら
set pc, flag_cell_deflag


set b, [a]
and b, 0xf
bor b, 0x20

set [a], b

set pc, flag_cell_return

:flag_cell_deflag ;旗を消す
set b, [a]
shr b, 4
ifn b, 2 ;旗が置かれてないなら
set pc, flag_cell_return

;旗が置かれてるので消す
set b, [a]
and b, 0xf
set [a], b
set pc, flag_cell_return

:flag_cell_return
set b, pop
set a, pop
set pc, pop



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:get_cell ;プレイヤーがいるマスの番地をaに返す
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

set a, [player_y]
mul a, [field_w]
add a, [player_x]
add a, [field_mem]
;aはプレイヤーがいるマスの番地を持ってる

set pc, pop



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:display_field ;フィールドを出力
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
set push, i
set push, j
set push, a

set j, 0

:display_field_j
set i, 0

:display_field_i

;プレイヤーがいるならプレイヤーを字を書く
ife i, [player_x]
ife j, [player_y]
set pc, display_field_player

;マス[i,j]の字を書く
jsr get_char_for_field_mem
jsr draw_to_screen
set pc, display_field_player_end

;プレイヤーを字を書く
:display_field_player
set a, "P"
jsr draw_to_screen

:display_field_player_end

add i, 1
ifn i, [field_w]
set pc, display_field_i

;iが一番右についた
add j, 1
ifn j, [field_h]
set pc, display_field_j

;jが一番下についた

set a, pop
set j, pop
set i, pop
set pc, pop



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:draw_to_screen ;モニタに文字aを[i,j]に出力
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
set push, b
set push, z
set push, c


set b, 0xf0 ;文字が白、背景が黒
shl b, 8
bor b, a ;字を追加

set z, j
mul z, [screen_w]
add z, i

set c, [monitor_mem]
add c, z
set [c], b ;メモリに書く

set c, pop
set z, pop
set b, pop
set pc, pop




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
:get_char_for_field_mem ;iとjでマスを指定し、aに時を返す
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
set push, z
set push, b
set push, c

;field_mem = 0xbc : b = 0: 開いてないマス、1: 開いてるマス、2:旗。
;c = 0~8: 周りの地雷の数（開いてないマスなら0）、;f: 地雷

set z, j
mul z, [field_w]
add z, i
add z, [field_mem]
set z, [z]
;zがマス[i,j]のデータを持つ

set b, z
shr b, 4
and b, 0x000f
;b = 0: 開いてないマス、1: 開いてるマス、2:旗。

ife b, 0
set pc, get_char_for_field_mem_closed

ife b, 2
set pc, get_char_for_field_mem_flag

;マスが開いてる
set c, z
and c, 0x000f
;c = 0~8: 周りの地雷の数（開いてないマスなら0）、;f: 地雷

ife c, 0xf
set pc, get_char_for_field_mem_mine

ife c, 0
set pc, get_char_for_field_mem_open

;周りに地雷があるマス
set a, 48
add a, c
set pc, get_char_for_field_mem_return


:get_char_for_field_mem_closed
set a, "?"
set pc, get_char_for_field_mem_return

:get_char_for_field_mem_flag
set a, "F"
set pc, get_char_for_field_mem_return

:get_char_for_field_mem_mine
set a, "X"
set pc, get_char_for_field_mem_return

:get_char_for_field_mem_open
set a, "0"
set pc, get_char_for_field_mem_return


:get_char_for_field_mem_return
set c, pop
set b, pop
set z, pop
set pc, pop